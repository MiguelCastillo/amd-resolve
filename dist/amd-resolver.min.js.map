{"version":3,"file":"bundle.js","sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/resolver.js","src/file.js"],"names":["Resolver","options","this","settings","File","require","prototype","resolve","name","i","length","pkg","pkgParts","pkgName","pkgTarget","shim","shims","packages","fileName","paths","plugins","split","pop","replace","shift","join","location","main","hasOwnProperty","exports","deps","imports","file","addExtension","baseUrl","urlArgs","module","fileUri","baseUri","mergedPath","parseUri","protocol","parseFileName","path","mergePaths","_file","protocolmark","undefined","toUrl","uriString","Error","isHttpProtocol","parseHttpProtocol","parseFileProtocol","uriParts","exec","normalize","drive","href","origin","hostname","port","search","hash","hasProtocol","test","isFileProtocol","protocolString","fileString","pathName","match","extension","fileParts","push","replaceExtension","regex","pathParts","pathCount","skip","newPath","unshift","base"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function() {\n  \"use strict\";\n\n  var File = require('./file');\n\n  /**\n   * @constructor Resolver - provides a way to take a configuration such as one\n   * from requirejs to convert module names/ids to module meta objects. Module meta\n   * objects contain information such as the url for the module, which can be used\n   * for retrieving the corresponding file from a remote sever.\n   */\n  function Resolver(options) {\n    this.settings = options || {};\n  }\n\n  /**\n   * Creates a module meta from a module name/id.\n   *\n   * @param {string} name - Module name/id\n   *\n   * @returns {{name: string, file: File, urlArgs: string, shim: object}}\n   */\n  Resolver.prototype.resolve = function(name) {\n    var i, length, pkg, pkgParts, pkgName, pkgTarget, shim;\n    var settings = this.settings,\n        shims    = settings.shim || {},\n        packages = settings.packages || [],\n        fileName = (settings.paths && settings.paths[name]) || name,\n        plugins  = name.split(\"!\");\n\n    // The last item is the actual module name.\n    name      = plugins.pop();\n    pkgParts  = name.replace(/[\\/\\\\]+/g, \"/\").split(\"/\");\n    pkgName   = pkgParts.shift();\n    pkgTarget = pkgParts.join(\"/\");\n\n    // Go through the packages and figure if the module is actually configured as such.\n    for (i = 0, length = packages.length; i < length; i++) {\n      pkg = packages[i];\n\n      if (pkg === pkgName) {\n        fileName = pkgName + \"/\" + \"main\";\n        break;\n      }\n      else if (pkg.name === pkgName) {\n        fileName = pkg.location ? (pkg.location + \"/\") : \"\";\n        fileName += pkgName + \"/\" + (pkgTarget || (pkg.main || \"main\"));\n        break;\n      }\n    }\n\n    if (shims.hasOwnProperty(name)) {\n      shim = {\n        name: shims[name].exports || shims[name].name || name,\n        deps: shims[name].imports || shims[name].deps || []\n      };\n    }\n\n    return {\n      name: name,\n      file: new File(File.addExtension(fileName, \"js\"), settings.baseUrl),\n      urlArgs: settings.urlArgs,\n      shim: shim,\n      plugins: plugins\n    };\n  };\n\n  Resolver.File = File;\n  module.exports = Resolver;\n})();\n","(function() {\n  \"use strict\";\n\n  function File (fileUri, baseUri) {\n    var fileName, mergedPath;\n    baseUri = baseUri || \"\";\n    fileUri = File.parseUri(fileUri);\n\n    if (fileUri.protocol || !baseUri) {\n      fileName = File.parseFileName(fileUri.path);\n    }\n    else {\n      baseUri    = File.parseUri(baseUri);\n      mergedPath = File.mergePaths(fileUri.path, baseUri ? baseUri.path : \"/\");\n      fileName   = File.parseFileName(mergedPath);\n    }\n\n    this._file    = fileUri;\n    this.protocol = fileUri.protocol ? fileUri.protocol + fileUri.protocolmark : undefined;\n    this.name     = fileName.name;\n    this.path     = fileName.path;\n  }\n\n  File.prototype.toUrl = function () {\n    var file = this;\n    return (file.protocol || \"\") + (file.path || \"\") + file.name;\n  };\n\n  /**\n   * Parses out uri\n   */\n  File.parseUri = function(uriString) {\n    if (!uriString) {\n      throw new Error(\"Must provide a string to parse\");\n    }\n\n    if (File.isHttpProtocol(uriString)) {\n      return File.parseHttpProtocol(uriString);\n    }\n    else {\n      return File.parseFileProtocol(uriString);\n    }\n  };\n\n  /**\n   * Parses out the string into file components\n   * return {object} file object\n   */\n  File.parseFileProtocol = function (uriString) {\n    var uriParts = /^(?:(file:)(\\/\\/\\/?))?(([A-Za-z-]+:)?[/\\\\d\\w\\.\\s-]+)/gmi.exec(uriString);\n    uriParts.shift();\n\n    // Make sure we sanitize the slashes\n    if (uriParts[2]) {\n      uriParts[2] = File.normalize(uriParts[2]);\n    }\n\n    return {\n      protocol: uriParts[0],\n      protocolmark: uriParts[1],\n      path: uriParts[2],\n      drive: uriParts[3],\n      href: uriString,\n      uriParts: uriParts\n    };\n  };\n\n  /**\n   * Parses out a string into an http url\n   * @return {object} url object\n   */\n  File.parseHttpProtocol = function (uriString) {\n    var uriParts = /^((https?:)(\\/\\/)([\\d\\w\\.-]+)(?::(\\d+))?)?([\\/\\\\\\w\\.()-]*)?(?:([?][^#]*)?(#.*)?)*/gmi.exec(uriString);\n    uriParts.shift();\n\n    // Make sure we sanitize the slashes\n    if (uriParts[5]) {\n      uriParts[5] = File.normalize(uriParts[5]);\n    }\n\n    return {\n      origin: uriParts[0],\n      protocol: uriParts[1],\n      protocolmark: uriParts[2],\n      hostname: uriParts[3],\n      port: uriParts[4],\n      path: uriParts[5],\n      search: uriParts[6],\n      hash: uriParts[7],\n      href: uriString,\n      uriParts: uriParts\n    };\n  };\n\n  /**\n   * Tests if a uri has a protocol\n   * @return {boolean} if the uri has a protocol\n   */\n  File.hasProtocol = function (path) {\n    return /^(?:(https?|file)(:\\/\\/\\/?))/g.test(path) === false;\n  };\n\n  /**\n   * Test is the input constains the file protocol delimiter.\n   * @return {boolean} True is it is a file protocol, othterwise false\n   */\n  File.isFileProtocol = function (protocolString) {\n    return /^file:/gmi.test(protocolString);\n  };\n\n  /**\n   * Test is the input constains the http/https protocol delimiter.\n   * @return {boolean} True is it is an http protocol, othterwise false\n   */\n  File.isHttpProtocol = function (protocolString) {\n    return /^https?:/gmi.test(protocolString);\n  };\n\n  /**\n   * Build and file object with the important pieces\n   */\n  File.parseFileName = function (fileString) {\n    var fileName;\n    var pathName = fileString.replace(/([^/]+)$/gmi, function(match) {\n      fileName = match;\n      return \"\";\n    });\n\n    return {\n      name: fileName,\n      path: pathName\n    };\n  };\n\n  /**\n   * Method to add an extension if one does not exist in the fileString.  It does NOT replace\n   * the file extension if one already exists in `fileString`.\n   *\n   * @param {string} fileString - File string to add the extension to if one does not exist\n   * @param {string} extension - Extension to add if one does not exist in `fileString`. The\n   *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.\n   * @returns {string} New fileString with the new extension if one did not exist\n   */\n  File.addExtension = function(fileString, extension) {\n    var fileName  = File.parseFileName(fileString),\n        fileParts = fileName.name.split(\".\");\n\n    if (fileParts.length === 1 && extension) {\n      fileParts.push(extension);\n    }\n\n    return fileName.path + fileParts.join(\".\");\n  };\n\n  /**\n   * Method to replace an extension, if one does not exist in the file string, it will be added.\n   *\n   * @param {string} fileString - File string to add the extension to if one does not exist\n   * @param {string} extension - Extension to be either added to `fileString` or to replace the extension in `fileString`. The\n   *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.\n   * @returns {string} fileString with the new extension\n   */\n  File.replaceExtension = function(fileString, extension) {\n    var regex = /([^.\\/\\\\]+\\.)[^.]+$/;\n    if (fileString.match(regex)) {\n      return fileString.replace(regex, \"$1\" + extension);\n    }\n    else {\n      return fileString + \".\" + extension;\n    }\n  };\n\n  /**\n   * Removes all forward and back slashes to forward slashes as well as all duplicates slashes\n   * and resolve all . and .. in the path.\n   * @param {string} path - Path to normalize\n   * @return {string} path with only one forward slash a path delimters\n   */\n  File.normalize = function (path) {\n    var pathParts = path.replace(/[\\\\/]+/g, \"/\").split(\"/\"),\n        pathCount = pathParts.length - 1,\n        skip      = 0,\n        newPath   = [];\n\n    while (pathCount >= 0) {\n      if (pathCount > 0) {\n        if (pathParts[pathCount] === \"..\") {\n          pathCount -= 1; skip++; continue;\n        }\n        else if (pathParts[pathCount] === \".\") {\n          pathCount -= 1; continue;\n        }\n      }\n\n      if (skip) {\n        pathCount -= skip;\n        skip = 0;\n      }\n\n      newPath.unshift(pathParts[pathCount]);\n      pathCount--;\n    }\n\n    return newPath.join('/');\n  };\n\n  /**\n   * Merges a path with a base.  This is used for handling relative paths.\n   * @return {string} Merge path\n   */\n  File.mergePaths = function (path, base) {\n    if (path[0] === '/') {\n      return File.normalize(path);\n    }\n\n    if (base && path) {\n      path = base + \"/\" + path;\n    }\n    else {\n      path = path || base;\n    }\n\n    return File.normalize(path);\n  };\n\n  module.exports = File;\n})();\n"]}